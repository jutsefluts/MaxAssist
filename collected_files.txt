import React, { useState } from 'react';

interface MultipleChoiceBlockProps {
  onMoveUp: () => void;
  onMoveDown: () => void;
  onRemove: () => void;
}

const MultipleChoiceBlock: React.FC<MultipleChoiceBlockProps> = ({
  onMoveUp,
  onMoveDown,
  onRemove,
}) => {
  const [question, setQuestion] = useState('');
  const [options, setOptions] = useState(['']);
  const [correctAnswerIndex, setCorrectAnswerIndex] = useState<number | null>(null);

  const addOption = () => setOptions([...options, '']);
  const handleOptionChange = (index: number, value: string) => {
    const updatedOptions = [...options];
    updatedOptions[index] = value;
    setOptions(updatedOptions);
  };
  const handleCorrectAnswerSelect = (index: number) => setCorrectAnswerIndex(index);

  return (
    <div className="border p-4 rounded-lg shadow-md">
      <div>
        <label>Question:</label>
        <input
          type="text"
          value={question}
          onChange={(e) => setQuestion(e.target.value)}
          className="w-full p-2 border rounded"
        />
      </div>

      <div className="mt-4">
        <label>Options:</label>
        {options.map((option, index) => (
          <div key={index} className="flex items-center mt-2">
            <input
              type="text"
              value={option}
              onChange={(e) => handleOptionChange(index, e.target.value)}
              className="w-full p-2 border rounded mr-2"
            />
            <input
              type="radio"
              name="correctOption"
              checked={correctAnswerIndex === index}
              onChange={() => handleCorrectAnswerSelect(index)}
            />
          </div>
        ))}
        <button onClick={addOption} className="mt-2 text-blue-500">
          Add Option
        </button>
      </div>

      <div className="flex space-x-2 mt-4">
        <button onClick={onMoveUp} className="text-gray-500">Move Up</button>
        <button onClick={onMoveDown} className="text-gray-500">Move Down</button>
        <button onClick={onRemove} className="text-red-500">Remove</button>
      </div>
    </div>
  );
};

export default MultipleChoiceBlock;
import React, { useState } from 'react';

interface OpenQuestionBlockProps {
  onMoveUp: () => void;
  onMoveDown: () => void;
  onRemove: () => void;
}

const OpenQuestionBlock: React.FC<OpenQuestionBlockProps> = ({
  onMoveUp,
  onMoveDown,
  onRemove,
}) => {
  const [question, setQuestion] = useState('');
  const [answer, setAnswer] = useState('');

  return (
    <div className="border p-4 rounded-lg shadow-md">
      <div>
        <label>Question:</label>
        <input
          type="text"
          value={question}
          onChange={(e) => setQuestion(e.target.value)}
          className="w-full p-2 border rounded"
        />
      </div>

      <div className="mt-4">
        <label>Answer:</label>
        <input
          type="text"
          value={answer}
          onChange={(e) => setAnswer(e.target.value)}
          className="w-full p-2 border rounded"
        />
      </div>

      <div className="flex space-x-2 mt-4">
        <button onClick={onMoveUp} className="text-gray-500">Move Up</button>
        <button onClick={onMoveDown} className="text-gray-500">Move Down</button>
        <button onClick={onRemove} className="text-red-500">Remove</button>
      </div>
    </div>
  );
};

export default OpenQuestionBlock;
import React, { useState } from 'react';
import dynamic from 'next/dynamic';
import 'react-draft-wysiwyg/dist/react-draft-wysiwyg.css';
import { EditorState, Modifier, ContentState } from 'draft-js';
import { EditorProps } from 'react-draft-wysiwyg';

const Editor = dynamic<EditorProps>(() => import('react-draft-wysiwyg').then(mod => mod.Editor), { ssr: false });

const AddLinkModal = ({
  isOpen,
  onClose,
  onAddLink,
}: {
  isOpen: boolean;
  onClose: () => void;
  onAddLink: (url: string, file?: File) => void;
}) => {
  const [url, setUrl] = useState('');
  const [file, setFile] = useState<File | null>(null);

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const selectedFile = e.target.files?.[0] || null;
    setFile(selectedFile);
  };

  const handleRemoveFile = () => {
    setFile(null);
  };

  const handleAddLink = () => {
    onAddLink(url, file || undefined); 
    setUrl('');
    setFile(null);
    onClose();
  };

  return isOpen ? (
    <div className="modal">
      <div className="fixed inset-0 bg-gray-600 bg-opacity-75"></div>
      <div className="fixed inset-0 z-50 flex items-center justify-center">
        <div className="bg-white rounded p-5 shadow-md max-w-md w-full">
          <h2 className="text-lg font-bold mb-4">Add Link or File</h2>
          <input
            type="text"
            value={url}
            onChange={(e) => setUrl(e.target.value)}
            placeholder="Enter URL"
            className="border p-2 w-full rounded mb-4"
          />

          <div className="mb-4">
            <label className="block mb-2">Upload a File (optional):</label>
            <input type="file" onChange={handleFileChange} />
            {file && (
              <div className="mt-2">
                <span className="text-gray-600">{file.name}</span>
                <button onClick={handleRemoveFile} className="ml-2 text-red-500 underline">Remove</button>
              </div>
            )}
          </div>

          <div className="mt-4 flex justify-end">
            <button onClick={onClose} className="px-4 py-2 bg-gray-300 text-gray-700 rounded mr-2">Cancel</button>
            <button onClick={handleAddLink} className="px-4 py-2 bg-blue-500 text-white rounded">Add Link</button>
          </div>
        </div>
      </div>
    </div>
  ) : null;
};

const TextBlock = ({
  onMoveUp,
  onMoveDown,
  onRemove,
}: {
  onMoveUp: () => void;
  onMoveDown: () => void;
  onRemove: () => void;
}) => {
  const [editorState, setEditorState] = useState(EditorState.createEmpty());
  const [isModalOpen, setIsModalOpen] = useState(false);

  const handleEditorChange = (state: EditorState) => {
    setEditorState(state);
  };

  const handleAddLink = (url: string, file?: File) => {
    const contentState = editorState.getCurrentContent();
    const selection = editorState.getSelection();

    if (url) {
      const contentStateWithEntity = contentState.createEntity('LINK', 'MUTABLE', { url });
      const entityKey = contentStateWithEntity.getLastCreatedEntityKey();

      const contentStateWithLink = Modifier.applyEntity(contentStateWithEntity, selection, entityKey);

      const newEditorState = EditorState.push(editorState, contentStateWithLink, 'apply-entity');
      setEditorState(newEditorState);
    }

    if (file) {
      const fileUrl = URL.createObjectURL(file);
      const contentStateWithFileEntity = contentState.createEntity('LINK', 'MUTABLE', { url: fileUrl });
      const entityKey = contentStateWithFileEntity.getLastCreatedEntityKey();

      const contentStateWithFile = Modifier.applyEntity(contentStateWithFileEntity, selection, entityKey);
      const newEditorState = EditorState.push(editorState, contentStateWithFile, 'apply-entity');
      setEditorState(newEditorState);
    }

    setIsModalOpen(false);
  };

  return (
    <div className="p-4 border border-gray-300 rounded-lg">
      <Editor
        editorState={editorState}
        onEditorStateChange={handleEditorChange}
        toolbar={{
          options: ['inline', 'blockType', 'list', 'link'],
          link: {
            options: ['link'],
            component: () => (
              <button onClick={() => setIsModalOpen(true)} className="px-2 py-1 text-sm bg-gray-200 rounded hover:bg-gray-300">Add Link</button>
            ),
          },
        }}
      />

      <AddLinkModal isOpen={isModalOpen} onClose={() => setIsModalOpen(false)} onAddLink={handleAddLink} />

      <div className="flex justify-between mt-4">
        <button onClick={onMoveUp} className="px-3 py-2 bg-gray-200 rounded hover:bg-gray-300">Move Up</button>
        <button onClick={onRemove} className="px-3 py-2 bg-red-500 text-white rounded hover:bg-red-600">Remove</button>
        <button onClick={onMoveDown} className="px-3 py-2 bg-gray-200 rounded hover:bg-gray-300">Move Down</button>
      </div>
    </div>
  );
};

export default TextBlock;
// features/lesson/LessonComposer.tsx
"use client";

import React, { useState } from "react";
import PhaseAccordion from "./PhaseAccordion";
import { LessonBlock, LessonPhase } from "@lessonTypes/lesson";
import { nanoid } from "nanoid";  // Import nanoid
import { useLessonBlocks } from "../../hooks/useLessonBlocks";  // Use custom hook to interact with Supabase

const LessonComposer: React.FC = () => {
  const { blocks, addBlock } = useLessonBlocks();  // Fetch blocks from Supabase and manage state

  // Maintain phases and their blocks in state
  const [phases, setPhases] = useState<LessonPhase[]>([
    { phaseName: "Introduction", blocks: [] },
    { phaseName: "Instruction", blocks: [] },
    { phaseName: "Practice", blocks: [] },
    { phaseName: "Conclusion", blocks: [] },
  ]);

  // Function to add a new block to a specific phase with a unique id
  const addBlockToPhase = (phaseIndex: number, block: LessonBlock) => {
    const updatedPhases = [...phases];
    const newBlock = { ...block, id: nanoid() };  // Generate unique string id with nanoid
    updatedPhases[phaseIndex].blocks.push(newBlock);
    addBlock(newBlock);  // Save block in Supabase
    setPhases(updatedPhases);  // Update local state
  };

  // Function to remove a block from a specific phase by index
  const removeBlockFromPhase = (phaseIndex: number, blockIndex: number) => {
    const updatedPhases = [...phases];
    updatedPhases[phaseIndex].blocks.splice(blockIndex, 1);
    setPhases(updatedPhases);
  };

  // Function to move a block up within a phase (by swapping with the block above)
  const moveBlockUpInPhase = (phaseIndex: number, blockIndex: number) => {
    if (blockIndex > 0) {
      const updatedPhases = [...phases];
      const blocks = updatedPhases[phaseIndex].blocks;
      [blocks[blockIndex - 1], blocks[blockIndex]] = [blocks[blockIndex], blocks[blockIndex - 1]];
      setPhases(updatedPhases);
    }
  };

  // Function to move a block down within a phase (by swapping with the block below)
  const moveBlockDownInPhase = (phaseIndex: number, blockIndex: number) => {
    const updatedPhases = [...phases];
    const blocks = updatedPhases[phaseIndex].blocks;
    if (blockIndex < blocks.length - 1) {
      [blocks[blockIndex + 1], blocks[blockIndex]] = [blocks[blockIndex], blocks[blockIndex + 1]];
      setPhases(updatedPhases);
    }
  };

  return (
    <div className="lesson-composer">
      {phases.map((phase, index) => (
        <PhaseAccordion
          key={index}
          phase={phase}
          onAddBlock={(block) => addBlockToPhase(index, block)}
          onRemoveBlock={(blockIndex) => removeBlockFromPhase(index, blockIndex)}
          onMoveUp={(blockIndex) => moveBlockUpInPhase(index, blockIndex)}
          onMoveDown={(blockIndex) => moveBlockDownInPhase(index, blockIndex)}
        />
      ))}
    </div>
  );
};

export default LessonComposer;"use client";

import React from "react";
import MultipleChoiceBlock from "./blocks/MultipleChoiceBlock";
import OpenQuestionBlock from "./blocks/OpenQuestionBlock";
import TextBlock from "./blocks/TextBlock";
import { LessonBlock, LessonPhase } from "@lessonTypes/lesson";
import { nanoid } from "nanoid"; // Ensure you import nanoid for generating unique ids

interface PhaseAccordionProps {
  phase: LessonPhase;
  onAddBlock: (block: LessonBlock) => void;
  onRemoveBlock: (index: number) => void;
  onMoveUp: (index: number) => void;
  onMoveDown: (index: number) => void;
}

const PhaseAccordion: React.FC<PhaseAccordionProps> = ({
  phase,
  onAddBlock,
  onRemoveBlock,
  onMoveUp,
  onMoveDown,
}) => {
  // Modify handleAddBlock to include lesson_phase
  const handleAddBlock = (blockType: LessonBlock["type"]) => {
    const newBlock: LessonBlock =
      blockType === "TextBlock"
        ? { id: nanoid(), type: "TextBlock", content: "", lesson_phase: phase.phaseName }
        : blockType === "OpenQuestionBlock"
        ? { id: nanoid(), type: "OpenQuestionBlock", question: "", answer: "", lesson_phase: phase.phaseName }
        : { id: nanoid(), type: "MultipleChoiceBlock", question: "", options: [], correctAnswers: [], lesson_phase: phase.phaseName };
    
    onAddBlock(newBlock); // Add block with lesson_phase
  };

  return (
    <div className="accordion-phase">
      <h2>{phase.phaseName}</h2>
      {/* Block Buttons */}
      <div className="flex space-x-2 mb-4">
        <button
          onClick={() => handleAddBlock("TextBlock")}
          className="bg-blue-500 text-white px-3 py-2 rounded-lg"
        >
          Add Text Block
        </button>
        <button
          onClick={() => handleAddBlock("OpenQuestionBlock")}
          className="bg-green-500 text-white px-3 py-2 rounded-lg"
        >
          Add Open Question Block
        </button>
        <button
          onClick={() => handleAddBlock("MultipleChoiceBlock")}
          className="bg-purple-500 text-white px-3 py-2 rounded-lg"
        >
          Add Multiple Choice Block
        </button>
      </div>

      {/* Render Blocks */}
      <div className="block-list">
        {phase.blocks.map((block: LessonBlock, index: number) => {
          switch (block.type) {
            case "TextBlock":
              return (
                <TextBlock
                  key={block.id}
                  {...block}
                  onMoveUp={() => onMoveUp(index)}
                  onMoveDown={() => onMoveDown(index)}
                  onRemove={() => onRemoveBlock(index)}
                />
              );
            case "OpenQuestionBlock":
              return (
                <OpenQuestionBlock
                  key={block.id}
                  {...block}
                  onMoveUp={() => onMoveUp(index)}
                  onMoveDown={() => onMoveDown(index)}
                  onRemove={() => onRemoveBlock(index)}
                />
              );
            case "MultipleChoiceBlock":
              return (
                <MultipleChoiceBlock
                  key={block.id}
                  {...block}
                  onMoveUp={() => onMoveUp(index)}
                  onMoveDown={() => onMoveDown(index)}
                  onRemove={() => onRemoveBlock(index)}
                />
              );
            default:
              return null;
          }
        })}
      </div>
    </div>
  );
};

export default PhaseAccordion;
// hooks/useLessonBlocks.ts
import { useState, useEffect } from 'react';
import { fetchBlocksFromSupabase, storeBlockInSupabase } from '../services/lessonService';
import { LessonBlock } from '@lessonTypes/lesson';

// Custom hook for managing lesson blocks
export const useLessonBlocks = () => {
  const [blocks, setBlocks] = useState<LessonBlock[]>([]);
  const [loading, setLoading] = useState<boolean>(true);

  // Fetch blocks from Supabase on component mount
  useEffect(() => {
    const fetchBlocks = async () => {
      const { data, error } = await fetchBlocksFromSupabase();
      if (data) setBlocks(data);
      setLoading(false);
    };

    fetchBlocks();
  }, []);

  // Add a new block and store it in Supabase
  const addBlock = async (block: LessonBlock) => {
    const { data, error } = await storeBlockInSupabase(block);
    if (data) setBlocks([...blocks, block]);  // Update local state after storing in DB
  };

  return { blocks, addBlock, loading };
};import { supabase } from '../utils/supabaseClient';
import { LessonBlock, TextBlock, OpenQuestionBlock, MultipleChoiceBlock } from '@lessonTypes/lesson';

// Function to store a lesson block in Supabase
export const storeBlockInSupabase = async (block: LessonBlock) => {
  // Define a variable to hold the block's data
  let blockData: any = {
    id: block.id,
    type: block.type,
    lesson_phase: block.lesson_phase // Include lesson_phase
  };

  // Narrow the type and add the corresponding properties
  switch (block.type) {
    case 'TextBlock':
      blockData.content = (block as TextBlock).content;
      break;
    case 'OpenQuestionBlock':
      blockData.question = (block as OpenQuestionBlock).question;
      blockData.answer = (block as OpenQuestionBlock).answer;
      break;
    case 'MultipleChoiceBlock':
      blockData.question = (block as MultipleChoiceBlock).question;
      blockData.options = (block as MultipleChoiceBlock).options;
      blockData.correctAnswers = (block as MultipleChoiceBlock).correctAnswers;
      break;
    default:
      throw new Error('Unknown block type');
  }

  // Insert the block data into Supabase
  const { data, error } = await supabase
    .from('lesson_blocks')  // Insert into lesson_blocks table
    .insert([blockData]);

  if (error) {
    console.error('Error inserting block:', error.message);
  } else {
    console.log('Block inserted successfully:', data);
  }

  return { data, error };
};

// Function to fetch all lesson blocks from Supabase
export const fetchBlocksFromSupabase = async () => {
  const { data, error } = await supabase
    .from('lesson_blocks')
    .select('*'); // Fetch all fields

  if (error) {
    console.error('Error fetching blocks:', error.message);
  } else {
    console.log('Blocks fetched successfully:', data);
  }

  return { data, error };
};
// utils/supabaseClient.ts
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL || 'https://bgeivmtdqqpfmmtvcmzv.supabase.co';
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImJnZWl2bXRkcXFwZm1tdHZjbXp2Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3Mjc0NTM3NTUsImV4cCI6MjA0MzAyOTc1NX0.NvrlExgHI22cZYPOudLol56WRtPFBqhHUDETAl5oW6s';

// Create a Supabase client
export const supabase = createClient(supabaseUrl, supabaseAnonKey);